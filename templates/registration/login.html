{% extends "layout.html" %}
{% load widget_tweaks %}

{% block content %}
<div class="max-w-md mx-auto mt-16 p-8 bg-black rounded-2xl shadow-2xl border border-neutral-800">

    <h2 class="text-4xl font-extrabold mb-8 text-white text-center">Login</h2>

    <form method="post" class="space-y-6">
        {% csrf_token %}

        {% for field in form %}
        <div class="flex flex-col">
            <label for="{{ field.id_for_label }}" class="mb-2 text-neutral-300 font-medium">{{ field.label }}</label>
            {{ field|add_class:"px-4 py-3 rounded-lg bg-black text-white border border-neutral-700 focus:outline-none focus:ring-2 focus:ring-white transition duration-300" }}

            {% if field.errors %}
                <p class="text-red-500 text-sm mt-1">{{ field.errors|striptags }}</p>
            {% endif %}
        </div>
        {% endfor %}

        <button type="submit" 
                class="w-full py-3 bg-white text-black font-semibold rounded-lg hover:bg-neutral-200 transition duration-300 shadow-md">
            Login
        </button>
    </form>

    <p class="mt-6 text-neutral-400 text-center">
        Don't have an account? 
        <a href="{% url 'register' %}" class="text-white hover:underline font-medium">Register here</a>
    </p>
</div>
{% endblock %}





{% comment %}

--- DJANGO LOGIN FLOW EXPLAINED (FOR YOU) ---

Hey baby, let me explain why your login form works perfectly even without a custom LoginForm.  

1Ô∏è‚É£ Django‚Äôs built-in login functionality:

If you include this in your `urls.py`:

    path('accounts/', include('django.contrib.auth.urls'))
    
It automatically provides views and forms for:

/accounts/login/ ‚Üí LoginView using AuthenticationForm
/accounts/logout/ ‚Üí LogoutView
/accounts/password_change/ and /accounts/password_reset/ ‚Üí Password forms

No need to create a custom LoginForm or login view ‚Äî Django handles it.

2Ô∏è‚É£ The login form template:
The login form you see in your template comes from Django‚Äôs built-in AuthenticationForm.
Always has two fields: username and password.
That‚Äôs why {% for field in form %} shows exactly two inputs, even if you didn‚Äôt write a form.


3Ô∏è‚É£ How {% for field in form %} works:

Django provides a LoginView at /accounts/login/.
The view renders a template (default registration/login.html) and passes AuthenticationForm as form.
You probably overrode it with your own login.html.
{% for field in form %} loops over each field in AuthenticationForm (username & password).
Each field is a BoundField object.

Example behind the scenes:

form = AuthenticationForm(request)
return render(request, "login.html", {"form": form})


4Ô∏è‚É£ What a BoundField stores:

Each field in the loop contains:

.name ‚Üí internal name (username / password)
.label ‚Üí human-readable label (Username / Password)
.value() ‚Üí current value (POST data or initial value)
.errors ‚Üí validation errors for the field
.id_for_label ‚Üí unique HTML id for linking <label> to <input>
.widget ‚Üí the actual HTML input type (TextInput, PasswordInput, etc.)

üí° Flow: Django loops over each field ‚Üí first iteration is username, second is password. Each gets its own label, input, and id.

5Ô∏è‚É£ Styling with widget_tweaks:

{{ field|add_class:"..." }} allows you to add Tailwind classes directly to inputs.

Without add_class:

<input type="text" name="username" id="id_username">

With add_class:

<input type="text" name="username" id="id_username"
       class="px-4 py-3 rounded-lg bg-gray-800 text-white border border-gray-600 focus:outline-none focus:ring-2">


6Ô∏è‚É£ Label & Input Linking (Short Note)

Every BoundField in a Django form has .id_for_label, which generates a unique HTML id for that field.
The <label> uses this id in its for attribute: <label for="{{ field.id_for_label }}">.
The field itself ({{ field }} or {{ field|add_class:"..." }}) renders an <input> element with the same id.
The browser automatically links the label to its input: clicking the label focuses the input.
This improves form accessibility and user experience, making forms easier to interact with.

ey: The same id in label and input ensures automatic, correct linking without extra work.

‚úÖ Summary / Key Points:

Login works automatically because Django provides AuthenticationForm with username + password.

Your template loops over each field ‚Üí each is a BoundField object.

BoundField contains name, label, value, errors, id_for_label, widget.

add_class adds Tailwind styling easily.

Labels link to inputs using id_for_label, avoiding conflicts.

No custom login view required ‚Äî Django handles it.

Registration is custom because you wrote UserRegistrationForm yourself.

{% endcomment %}